#summary PNaCl Translation Caching: In Javascript or In Browser?


= Introduction =

For PNaCl, we wish to be able to cache the translation of *bitcode files* _to_ *ELF files*. One question is, how should we manage the cache? Inside the browser, as a web app, or something in between?

Here is a typical scenario: a user just opened multiple window tabs, each trying to load the same PNaCl app composed of N bitcode files from M different domains. These bitcode files need to be translated to ELF files that are eventually used by the dynamic linker (a nexe). The system should cache the ELF files to avoid re-translating the bitcode when unchanged.

Here is the high-level flow for a single bitcode file:

{{{
  var hash = GetHash("http://example.com/lib/libz.so.1.0.bc")

  var elf_file = GetFromCache(hash);
  if (!elf_file) {
    var pnacl_file = plugin.fetchUrl("http://example.com/lib/libz.so.1.0.bc");

    // Compute hash, since bitcode may have changed in the mean time.
    var hash2 = CalcHash(pnacl_file);

    var elf_file_w = CreateCacheEntry(hash2);

    // We don't know how much data Translate will write to the cache entry?
    Translate(pnacl_file, elf_file_w);
    
    elf_file = MakeReadOnly(elf_file_w);
  }

  // Use elf_file...

}}}

== Requirements ==

This cache and translation system must have at least the following capabilities:

 * Handle concurrency.
   * Avoid redundant concurrent translations.
   * Avoid races in writing to the cache.
 * The cross-domain fetch permission should apply to the derived data (translated elf in the cache).
   * I.e., the elf should be available to the consumer (dynamic linker) that is pulled from another domain.
 * Supply file descriptors of cache entries to loader/linker.
 * Supply file descriptors to translator nexe.
 * Evict and unlink files when at capacity.
 * Nice to have: immutable files to be able to map files directly instead of copying data.


Other capabilities:

 * Have per-app quotas.
 * Do not cache the bitcode files (only the ELF files), since the bitcode files can be quite large.
 * Clear cache when browser cache is cleared(?).


= Options =

There are at least two options to consider:

 # (A) Manage the cache via a web app and back it with HTML FS.
 # (B) Manage the cache in the browser and back it with real files in a reserved directory.

Let's consider how the requirements will be satisfied by each option.

== Option A: Manage the cache via a web app, backed by HTML FS ==

Being a Web App, it will need storage. The only HTML storage option that appears to have the capacity and capabilities required is HTML FS. Here is a layout of the components and how they communicate for reference. Each box is an element that may be hosted on a different domain.

{{{

 [ Bitcode 1 ] <------\
 [ Bitcode 2 ] <------\
 [ PNaCl App Page ] <-----> [ Cache Web App w/ FS ] <--> [ Translator nexe ]
 [ Dynamic Linker ] <--/ 

}}}

Let's go over what is needed:

 * Manage concurrent requests
   * We can serialize accesses if the Cache App is a SharedWorker

 * Get file descriptor of files in cache
   * Can we reuse the url-to-fd mechanism for FS-based URLs?
   * i.e., fd = plugin.fetchURL(fileEntry.toURI())

 * Pass file descriptors out of the cache to a few known nexes.
   * Because the Cache Web App is in a different domain from the other components, we something like postMessage send of FDs.
   * FDs will need to be wrapped to pass them around in JavaScript.
   * In that case, will FDs close when JS ref-counts go to zero?

 * Unlink files
   * Use fileEntry.remove(succCB, errCB). The spec doesn't specify the semantics if a file is still in use. A worry is that for the normal Windows FS, you get an error, and this would introduce platform differences. Perhaps we can just gracefully handle errors. If the cache is full, we would have to delay a cache-put until a remove is finally successful. If we cannot unlink anything (all files are busy), then we would have to fail to add to the cache and the subsequent load will fail?

 * Immutable files
   * The Cache Web App does have a domain-isolated HTML FS, but how do we feel about making it trusted code?


Extensions made will be available to all Web Apps and not used solely by the translation cache.

Other Issues:

 * Every PNaCl App will have an iframe pointing to the Cache App in order to share the cache, so... Mark: can you explain the issue with possible proposed extensions (for all Web Apps) + possible exploits in the renderer?
 * Extensions appear to be:
   * urlToFD(fileEntry.toURI())
   * postMessage for an FD


== Option B: Manage the cache in the browser, backed by a single directory ==

With this option, the browser will have a Cache-managing process that is given access to a single directory in the native file system. We do not extend the capabilities of web apps (besides supplying a bitcode translation cache).

 * Manage concurrent requests
   * We will need a broker process in the browser.

 * Get file descriptor of "file" in cache
   * Trivial to get.

 * Pass file descriptors out of cache to a few known nexes
   * Use chrome IPC between cache broker and NaCl plugins.
   * Re: garbage collection -- ownership transfer from cache to consumer.

 * Unlink files
   * Although unlinking may fail for in-use files on Windows, we manage the cache, so we can gracefully handle this.

 * Immutable files
   * The cache broker manages the directory. One problem is that files are externally visible, but if that is the only way to modify cached files then you have already been owned?


Other issues:

 * We need to be careful about detecting translator.nexe changes. Possibly we could split the cache directory up based on the version of the translator.nexe.

= Other Possibilities =

== Option B-prime: : Manage the cache in the browser, backed by browser cache ==

We could go with Option B, but instead of giving the cache broker ownership of a fresh/isolated directory we could reuse the browser cache.

 * Browser cache may not be allocated enough space to be useful.
 * Ensure cache entries will can be consumed as FDs.
 * Cache broker must synchronize with the browser cache.
 * Likely will not want to share cache-replacement scheme with the browser cache. A cache miss for translated nexes requires re-computating in addition to re-downloading files.


= Conclusion =

TODO.

= Related =