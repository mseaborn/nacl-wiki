#summary PNaCl Translation Caching: In Javascript or In Browser?

_Draft_

= Table of Contents =

<wiki:toc max_depth="2" />

= Introduction =

For PNaCl, we wish to be able to cache the translation of *bitcode files* _to_ *ELF files*. One question is, how should we manage the cache? Inside the browser, as a web app, or something in between?

Here is a typical scenario: a user just opened multiple window tabs, each trying to load the same PNaCl app composed of N bitcode files from M different domains. These bitcode files need to be translated to ELF files that are eventually used by the dynamic linker (a nexe). The system should cache the ELF files to avoid re-translating the bitcode when unchanged.

Here is the high-level flow for a single bitcode file:

{{{
  var hash = GetHash("http://example.com/lib/libz.so.1.0.bc")

  var elf_file = GetFromCache(hash);
  if (!elf_file) {
    var pnacl_file = plugin.fetchUrl("http://example.com/lib/libz.so.1.0.bc");

    // Compute hash, since bitcode may have changed in the meantime.
    var hash2 = CalcHash(pnacl_file);

    var elf_file_w = CreateCacheEntry(hash2);

    Translate(pnacl_file, elf_file_w);
    
    elf_file = MakeReadOnly(elf_file_w);
  }

  // Use elf_file...

}}}

See NameResolutionForDynamicLibraries for details on specifying URLs of libraries.

== Requirements ==

This cache and translation system must at the very least satisfy the following requirements:

 * Handle concurrency.
   * Avoid redundant concurrent translations.
   * Avoid races in writing to the cache.
 * Supply file descriptors to the translator nexe.
 * The cross-domain fetch permission should propagate to the derived data (translated ELF files in the cache).
   * I.e., the ELF files should be available to the consumer (dynamic linker) that is pulled from another domain.
 * Supply file descriptors of cache entries to dynamic linker.
 * Evict and unlink files when at capacity.
 * Use immutable files so that the linker will be able to map files directly instead of copying the data.

Other requirements:

 * Handle crashes: Cache "put" operation should be atomic. Put another way, the cache should never return a partially-written file.
 * Do not cache the bitcode files (only the ELF files), since the bitcode files can be quite large and are redundant.
 * Clear cache when browser cache is cleared, or via other mechanisms.
   * Useful for deterministic testing.
   * Possibly relevant to privacy / not revealing browsing history via timing.
 * Retain ability to test translator as a standalone program.
 * Be sure not to block the UI threads.
 * Compatibility with third-party translator.nexes (e.g., one with fewer optimizations but faster startup), or multiple versions of translator.nexes.
 * Have per-app, per-domain, per-X quotas.

Other issues to consider:

 * Portability of approach to other browsers.
 * Do we reuse translator instances to translate multiple bitcode files?

= Options =

There are at least two options to consider:

 * Option A: Manage the cache via a web app and back it with HTML FS.
 * Option B: Manage the cache in a browser broker process and back it with real files in a reserved directory.

Let's consider how the requirements will be satisfied by each option.

== Option A: Manage the cache via a web app, backed by HTML FS ==

Being a Web App, it will need storage. The only HTML storage option that appears to have the capacity and capabilities required is the HTML Filesystem API ([http://dev.w3.org/2009/dap/file-system/pub/FileSystem/ spec], [http://www.html5rocks.com/tutorials/file/filesystem/ demo]). 

Here is a representative layout of the components involved and how they communicate. Each box is an element that may be hosted on a different domain.

{{{

 [ Bitcode 1 ] <------\
 [ Bitcode 2 ] <------\
 [ PNaCl App Page ] <-----> [ Cache Web App w/ FS ] <--> [ Translator nexe ]
 [ Dynamic Linker ] <--/ 

}}}

Let's go over what is needed:

 * Manage concurrent requests
   * [http://dev.w3.org/html5/workers/#shared-workers-introduction SharedWorkers] allow us to refer to a single Javascript worker across different windows. This single Javascript worker can handle serialization.

 * Get file descriptors out of files in cache
   * Ideally we would have urlAsNaClDesc apply to HTML FS based URLs.
   * i.e., fd = plugin.urlAsNaClDesc(fileEntry.toURI())

 * Pass file descriptors out of the cache to dynamic linker and translator nexes.
   * Since the Cache Web App is in a different domain from the other components, we need to extend [http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#web-messaging postMessage] to send FDs across domains.
   * FDs will need to be wrapped to pass them around in Javascript.
   * In that case, will FDs close when JS ref-counts go to zero?

 * Unlink files
   * Use [http://dev.w3.org/2009/dap/file-system/pub/FileSystem/#widl-Entry-remove fileEntry.remove](succCB, errCB). The spec doesn't specify the semantics if a file is still in use. A worry is that for the normal Windows FS, you get an error, and this would introduce platform differences. 
   * Perhaps we can just gracefully handle errors.
   * We can only gracefully handle the case where remove() gets the error, not the reader/writer getting the error.
   * If the cache is full, we would have to delay a cache-put until a remove is finally successful. If we cannot unlink anything (all files are busy), then we would have to fail to add to the cache and the subsequent load will fail.

 * Immutable files
   * The Cache Web App does have a domain-isolated HTML FS, but how do we feel about making it trusted code?

Extensions made will be available to all Web Apps and not used solely by the translation cache.

In summary, the extensions appear to be:

 * plugin.urlAsNaClDesc(fileEntry.toURI())
 * window.postMessage for an FD
 * Make semantics of unlinking concrete  


== Option B: Manage the cache in a browser broker process, backed by a single directory ==

With this option, the browser will have a Cache Broker Process that is given access to a single directory in the native file system. We do not extend the capabilities of web apps (besides supplying a bitcode translation cache).

 * Manage concurrent requests
   * We will need a broker process in the browser.

 * Get file descriptors out of files in cache
   * Trivial to get.

 * Pass file descriptors out of the cache to dynamic linker and translator nexes.
   * Use chrome IPC between cache broker and NaCl plugins.
   * Re: garbage collection -- ownership transfer from cache to consumer.

 * Unlink files
   * Although unlinking may fail for in-use files on Windows, we manage the cache, so we can gracefully handle this.

 * Immutable files
   * The cache broker manages the directory. One problem is that files are externally visible, but if that is the only way to modify cached files then you have already been owned?


Other issues:

 * We need to be careful about detecting translator.nexe changes. Possibly we could split the cache directory up based on the version of the translator.nexe.

= Variants of Options =

Here, we explore variations on the above options.

== Option B-prime: Manage the cache in a browser broker process, backed by browser cache ==

We could go with Option B, but instead of giving the cache broker ownership of a fresh/isolated directory we could reuse the browser cache.

 * The chrome cache has an option to store entries as as individual files, so we can still get FDs.
   * Will need to investigate.
 * Chrome already has separate caches for video, etc., so we can still tune the size of the cache, don't have to worry about competing with other types of files for cache space, etc.
 * We get to reuse the chrome cache meta-data for LRU, journaling, clearing the cache happens naturally, etc.

== Option B-double-prime: Manage the cache in the browser process, backed by browser cache ==

This is a variation of Option B where we add logic to the browser process instead of having a separate broker process.

 * May be easiest for a first-cut.
 * Do not need to wait for a general Pepper Broker Abstraction.

= Current Leanings =

Go with Option B double-prime, since it does not need to face unspecified behavior (unlink behavior in the FS), and does not require extensions to the web app platform. We also get to reuse much of the chrome code including its cache.

= Other Requirements / Issues =

This section explores the secondary requirements and issues related to client-side translation caches.

== Compatiblity with Alternative Translator.nexes ==

We can create a separate cache instance based on a hash of the translator.nexe. TODO: Look into the details of doing so with each option.

== Notes on Persisting Instances of the Translator to Translate Multiple BC files ==

Persisting and reusing instances of the translator nexe will save on startup cost. However, even if we limit this persistence/sharing to a single domain there are ways in which a malicious individual could affect multiple domains. Mark's example:

 * Translator starts up
 * Translator receives a malicious.bc and gets owned
 * Translator behavior is now changed
 * Changed translator persists and mistranslates domainA:libgood.so.bc, which has hash X. The mistranslation doubles numeric literals that may refer to prices.
 * Next time another app wants to use domainB:libgood.so.bc which also has hash X. Since we only check hashes in the cache, the dynamic linker will be supplied with the cached mistranslated version.


= Related =

DSO name resolution design document:
NameResolutionForDynamicLibraries