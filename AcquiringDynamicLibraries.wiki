#summary How dynamic libraries will be fetched

= Acquiring dynamic libraries =

_Draft_

<wiki:toc/>

== Overview ==
The normal model for shared libraries in Unix is that libraries are installed into the filesystem by a package manager into the centralised locations `/lib` and `/usr/lib`.  Native Client, however, does not have a built-in filesystem, and the concept of a centralised package manager is not applicable to web apps.  Instead, we propose to use a virtualised filesystem namespace, implemented via IPC calls.  Each NaCl process may be launched with a custom filesystem namespace populated with the library versions the web app chooses to use.

== How libraries will be fetched and loaded ==
Each .so file can be fetched from a URL.

There are at least two interfaces through which libraries can be fetched for use in NaCl processes:
 * XMLHttpRequest
 * NaCl's `__urlAsNaClDesc()`, a method provided to Javascript on the NaCl plugin object

In principle, any mechanism that Javascript code can currently use for fetching data can be used for fetching libraries.

The main advantage of the latter, NaCl-specific interface is that it can be used with an mmap() interface which has the potential to allow library and executable code to be mapped rather than copied into memory.  Whether this potential can be realised depends on the underlying mechanism for dynamic loading (see DynamicLoadingOptions).  If mapping can be used, it means that two NaCl processes using the same library will share physical memory for the library, provided that the library is retained in the browser's cache.

=== Executables ===
Executables will be fetched by the dynamic linker in the same way as libraries.

== Sharing libraries across sites ==
It will be desirable to share library files across sites, so that the browser does not have to download identical files multiple times.  This issue already occurs for Javascript libraries.  NaCl executables and libraries are expected to be larger than Javascript libraries which makes this issue more important for NaCl.

=== Background: Same Origin Policy ===
XMLHttpRequest is constrained by a Same Origin Policy (SOP).  `__urlAsNaClDesc` will also be constrained by a SOP.  (Note that the NaCl NPAPI plugin has to implement the SOP itself because NPAPI does not provide a way to reuse the browser's SOP.)

The main reason for the SOP is that XMLHttpRequest requests convey cookies -- a type of [http://en.wikipedia.org/wiki/Ambient_authority ambient authority].  The Same Origin Policy is not intended to prevent web apps from sending messages across origins; it is only intended to prevent the web app from seeing the server's response to the request.  (Sending cross-origin messages can already be done using mechanisms other than XMLHttpRequest, including redirects and `<img>` elements.)

=== Comparison: `script` element ===
Loading libraries in NaCl is analogous to loading Javascript files via the `<script src=...>` element.  Interestingly, `<script>` is not constrained by the SOP.  By setting the response's content-type to `text/javascript`, the server effectively opts in to revealing the response to the web app.  Supposedly, the response is not revealed directly to the web app.  The DOM, a trusted part of the browser, evaluates the Javascript code, and the web app gets access only to the values the script assigns to variables.  In practice, one cannot rely on `text/javascript` data from being revealed across origins.

In NaCl's case, however, interpreting .so files is unambiguously the responsibility of untrusted code.  We have to reveal the fetched data to the web app, so NaCl cannot be as unconstrained as the `<script>` tag.

The `<script>` element permits a centralised model for sharing library code.  Suppose multiple web apps use the library `libjfoo.js`.  If this is hosted at `http://libjfoo.org/libjfoo-1.0.js`, the web apps can opt to link to this URL.  The down side of using the `<script>` element in this way is that the web apps will be vulnerable to the centralised site, `libjfoo.org`.  This site can change the file contents it serves up and thereby run arbitrary Javascript in the context of the web apps.  Since the script text is not available across origins, the web app cannot check the text against a hash before `eval`'ing it.

=== Fetching libraries across origins ===
For NaCl, web apps could fetch libraries using CORS or Uniform Messaging (formerly known as GuestXHR), which are not NaCl-specific.

We might also wish to allow decentralised sharing of files.  For example, sites A and B both host `libfoo.so`.  If the browser has already downloaded `libfoo.so` from site A, it won't need to download it again from site B, and vice-versa.  Schemes for doing this by embedding secure hashes into URLs have been proposed (see Douglas Crockford's post).

This problem is not unique to NaCl, so we should not adopt a solution which is NaCl-specific.

== Prefetching ==
The naive approach is to fetch each library file as ld.so requests them.  We could reduce latency by listing all the libraries we expect to load up-front.  The Javascript code can request the files on startup, to fetch them into the browser's cache.  This would just mean that the requests are pipelined.

== Versioning ==
As with static linking, each web app gets to choose its own version of libc and other libraries.  Furthermore, different NaCl processes in the same web app can use different libc versions.  Libc is not supplied by the browser.

We don't expect there to be a huge number of libc versions, but older and newer versions of the same libc are likely to be around at the same time, as are different libc implementations (such as newlib and glibc).

Web apps get to pick a set of libraries that are known to work well together.  This is analogous to selecting a set of Javascript libraries, or selecting a set of packages for a software distribution such as Debian or Fedora.  This way we can avoid "[http://en.wikipedia.org/wiki/Dll_hell DLL hell]"; libraries are not the responsibility of the end user.

This provides extra flexibility that is not available to typical applications on Linux when packaged with commonly-used packaging systems like dpkg or RPM.  Packaging systems such as Zero-Install and Nix allow multiple library versions to coexist in the same way that I am proposing for NaCl.

Though we have this extra flexibility we will still have all the versioning mechanisms that are available in ELF shared libraries normally:  libraries can opt to provide stable ABIs and declare interfaces via [http://en.wikipedia.org/wiki/Soname sonames] and ELF symbol versioning; we get the benefit of separate compilation.

Upgrading libraries is the responsibility of the web app.