#summary The system that ensures NaCl can safely run on your computer.

= Introduction =

There is currently no design doc for our Platform Qualification routine, a check which runs as the sandbox starts.  This page is intended to evolve into such a design doc.

= Background =

Native Client relies on hardware features on all platforms, even those where we use Software Fault Isolation:
   * On both x86 platforms, we rely on the instruction decoder's behavior, which must match our validator in terms of instruction length, etc.
   * On x86-32, we rely on the hardware segment registers.
   * On x86-64 and ARM, we rely on Data Execution Prevention being present and active.  (Intel calls this XD; AMD calls it NX; ARM calls it XN; because of this babel we've chosen the vendor-neutral term DEP.)

We also require certain features to be present in the operating system.

We cannot blindly assume that our requirements are met, because of variations in the hardware and software beneath us:
   * We support a range of x86 implementations (currently dating back to the 80486).  Older machines may decode newer instructions (e.g. SSE3) differently or incorrectly.
   * DEP is a recent feature on both x86 and ARM.  On x86, it can be disabled in the BIOS.  On ARM, it requires a relatively recent Linux kernel.
   * Linux is infinitely configurable, and can be compiled without features we rely on (such as SysV SHM).

= Things We Need To Check =

== Cross-Architecture Common Checks ==
  * We must be able to secure a contiguous chunk of VA space (currently 1GiB) that meets the architecture's requirements.  (Note: this is not actually verified during platform qualification, but during address-space squatting.  Note also that this may change from moment to moment on Windows.)
  * The CPU must not be on a blacklist (TBD) of CPU models with known issues.  (How the CPU is identified is architecture-specific.)

== x86-Specific Checks ==
  * We require the CPUID instruction.  We also require that it works.

== x86-64-Specific Checks ==
  * We require NX support to be present in both the CPU and OS.

== ARM-Specific Checks ==
  * We require a minimum architecture of ARMv7 (currently v7-A, to be precise).  (Note: this could be relaxed to ARMv6T2 without correctness impact, but we'd lose parity with x86's atomic ops by losing `ldrexd` and `strexd`.)
  * We may need to detect the particular FPU variation and scribble incompatible instructions with HLTs.  ("May" because, in practice, the FPU ops are often coprocessor ops, and we can reason about their effects without knowing which precise rev we're dealing with -- since we can reliably decode unknown instructions in the coprocessor space.)

=== ARM with XN support ===
_This is broken out only because we're not sure whether we can reasonably expect all ARM kernels to support XN._

  * We require the underlying operating system to correctly configure XN bits for our non-executable sections.
  * We require the boundary between text and data to fall at the edge of a page.  (Not enforced by PQ per se, just noting it here.)

=== ARM w/o XN support ===
  * We require the boundary between text and data to fall at a power of two from the base address.

== Linux-Specific Checks (All Archs) ==
  * SysV SHM must be supported and pass certain feature tests, including interacting predictably with mmap (see `src/trusted/platform_qualify/linux/sysv_shm_and_mmap.c`).

== Mac OS X-Specific Checks (All Archs) ==
_No checks currently implemented._

== Windows-Specific Checks (All Archs) ==
  * `GetVersionEx` must be present, operational, and indicate Windows 5.1 (XP) or later.

= How the Checks Happen =

  * `sel_main` calls NaClOsIsSupported, which does rudimentary OS version checking on Windows and some SysV SHM analysis on Linux.
  * The `platform_qual_test` standalone binary (in `src/trusted/platform_qualify`) exercises the rest of the checks...but is invoked from what?