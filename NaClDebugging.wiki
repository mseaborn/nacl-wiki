= Introduction =

== Goal ==
The goal is to provide a mechanism for symbolic debugging of the untrusted aspects of Native Client applications, while minimizing impact on the Service Run time development and security.  The trusted service run-time should be invisible to the user much the way that OS system calls are invisible during casual application debugging.

== Summary ==
Both for speed of development, and portability, we have decided to use the GDB serial debug protocol (a.k.a. RSP - Remote Serial Protocol).  This protocol runs between the target (the application being debugged) and the host (the debugger instance, usually GDB).   Using RSP allows us to maintain compatibility with GDB based debuggers while focusing on the larger windows audience to enable windows based debugging tools.  The stub and link libraries discussed here are a portion of the overall solution.

== Components ==
The entire debugging solution includes connection management, packetization of exchange of messages, control of the target, synchronization with the host, loading, processing, and interpreting debugging (DWARF) information, and interaction with the user through a Visual Studio Plug-In.   This document focuses on the communication and target control aspects which together form the dynamically loadable debug stub.

=== gdb_link ===
Gdb_link is a static standalone library providing an abstraction of the communication between a GDB target and GDB host.  Commutation happens over a GDBTransport, which can be either socket or system pipe based.  Messages are exchanged in the form of discrete GDBPacket objects which are capable of streaming values in and out of them.  Data traversing the GDBTransport conforms to the GDB Remote Serial Protocol to allow a standard GDB process to connect via socket. The library provides an abstract class for defining the host and target, from which implementers can derive a stub or debugger and ensure compatibility.  The gdb_link library provides additional support for GDB/RSP related data such as architecture specific thread context structures, defining register order, enumerating signal/exception, etc...

=== nacl_target_stub ===
The nacl_target_stub library implements the back end of the gdb debugging stub, handling exceptions, processing queries, and generating responses.  The nacl_debug_stub is loaded dynamically and provides a single interface similar an ioctl which the Service Run-time can use to provide debugging support.  This reduces the impact and footprint of the debug_stub on the service Run-time.  

=== Dwarf2Reader ===
Dwarf2reader is a stand alone library for parsing Dwarf debugging information.  The dwarf2reader provides an interface from which one can implement callbacks to process the dwarf data.

=== Dwarf2XML ===
Dwarf2XML is a helper utility which will take a NEXE and extract the Dwarf data in a more human readable form.  

=== NaClvsDebugHelpers ===
This library provides a mechanism for the C# based PlugIn to communicate with the gdb_link library as well as provide a mechanism to load and process the debugging information.

=== NaClvsPackage ===
The NaClvs.Package implements the plug-in which communicates with Visual Studio to provide a native development and debugging environment within the VS framework.

= The Debug Stub = 
The debug stub is activated by checking for a debugging environment variable.  If the environment variable is set, the service run time with attempt to load and use the debugging module.   Once loaded, the debugging module works in co-operation with the parent application (most likely Chrome), for logging debugging information and events.  It is advisable that the parent application do something to make the logging obvious such as opening a console style window, to ensure users to do not accidentally weaken the security of the application by accidentally enabling debugging.

== Communication between the Stub and Service Run-time ==
Communication with the stub happens through a single library function in the service run-time.  This function is in the form of:
{{{
int NaClDebugStubCommand(uint32 CMD, void *data, uint32 size);
}}}
Underneath, this function checks for the presence of the debug stub module, if found, prepends version information before calling the dispatch function with in the DLL.  The function will return zero on success, or an error code on failure.  It is not expected that the service run-time will need to handle error cases since the debug stub is not require for correct execution of the Service Runtime.  In addition, any events will be logged, providing the user to determine if the debugging system is working.  However, a non-zero error allows us to indicate that data would normally be passed back within the data block can not be assumed to be valid.  The actual function exported by the library is:
{{{
int NaClDebugStubDispatch(uint32 version, uint32 CMD, void *data, uint32 size);
}}}
This technique allows us to centralize checking for the presence of the debug stub as well as validating version compatibility.  Within the debug stub, the dispatch function is responsible for validation of the parameters before dispatching to the individual handlers.

== Debugging Events ==
The debugging stub is interested in several events including load of the NEXE, load of additional modules, creation of threads, and destruction of threads.  

=== Initialization ===
On initialization of the debugging stub, the stub must be configured with parameters for communication with the outside world, as well as the untrusted memory range.  This includes the address and choice of socket or pipe.  This needs to be the first debug stub command called.  The debug stub will instantiate a new thread which will responsible for communicating with the debugger.

=== NEXE/Module Load ===
After load and verification of the NEXE, but before it's execution, the Service Run-time must inform the debug stub the name and path of the NEXE.  Additionally any dynamic module load will also need to inform the debug stub for communication to the debugger.

In the future, we plan to provide an hash of the data and executable sections of the NEXE (excluding debugging sections).  This information can be queried by the debugger to help validate the loaded symbols match the NEXE even if it has been stripped.

=== Thread Creation ===
On creation of a NaClAppThread, the new thread must call into the debug stub before it switches to the untrusted context.  This allows the debug stub to track the thread as well as change it's signal/exception handler.  To ensure the debugger gets catches the signal/exception, the Service Run-time must guaranty it calls the debug_stub after any other code (such as breakpad) has inserted a handler.

== Processing Exceptions ==
When an exception takes place, the inserted exception handler will catch the exception or signal, and update it's state in the debug thread object which tracks it (such as storing registers).  The thread will then block on a OS synchronization object.  The debugging thread created at initialization of the debug stub will eventually detect the exception by scanning through the list of active thread objects at which point it will sleep the other threads and signal to the debugger that the NEXE is in an exception state.  When the debugger signals it's time to continue, the debugging thread will mark the debug thread structure with a flag to signal it may continue, it should step, or if the thread should be killed.  It will then signal the thread to allow to clean itself up or destroy itself.  If the thread continues, it will pull the new register state (in case it was modified during debugging) and update the exception context before returning.

=== Security Issues ===
Unfortunately under Windows, the thread context of the excepted thread is actually stored within the untrusted stack of the thread which took this exception.  This allows for a security hole where another malicious thread could modify either the exception context itself, or the return pointers within stack making any function return unsafe.   There are several things we can do in terms of synchronizing the start and stop of various threads, but this really just reduces the size of the exposure window without eliminating it.
One possible choice is to allow the user to chose if it wants to support unsafe debugging.  In the safe case, all excepted threads would be terminated, while in the unsafe case the debuggers provides the stepping and continue features of a normal debugger.

=== System Calls ===
While exceptions should never happen within a System Call, it is possible that while one thread takes an exception, another is in a system call.  It is also possible the the debugger has signaled a force break and the thread of interest is within a system call.  When a thread is put to sleep by the debug thread, it checks first to see if the app thread was in a system call.  If so, it uses the thread context preserved on entry into the system call.   We do copy the context information from the debug thread object into the app thread before waking it up, since this would lead to unexpected behavior.  Instead the stub will signal the debugger with an error if an attempt is made to modify the registers of a thread within a system call.
