#summary Tasks for the nacl-glibc port

= nacl-glibc tasks =

Stages:
 * Build a statically-linked glibc and run a "hello world" program under sel_ldr.  This should work both in `-d` debug mode and with ncval_stubout (which replaces non-validating instructions with HLTs). See http://codereview.chromium.org/2072005/show
 * Build a dynamically-linked glibc and run ld.so under sel_ldr to print its help message
 * Run ld.so on a "hello world" executable; this uses libc.so
 * Run more complex programs, e.g. Python
 * Run programs in the context of the web browser
 * Fix all validation failures so that we don't need ncval_stubout
 * Be able to run glibc's test suite
 * Port to NaCl-x86-64
    * Compiler may need substantial fixing to support `-fPIC`; this is known not to work yet
 * Port to NaCl-ARM
 * Port to PNaCl
 * Add a library function for allocating space in the dynamic code area so that JIT compilers can load code without treading on the feet of ld.so
 * Ensure that C++ exception handling and dl_iterate_phdr() work.  This may require a way for ld.so to discover its own ELF Program Headers.  We may need to munge ld.so to put a copy of the PHDRs into its data segment.

Build integration:
 * Set this up on Buildbot
 * Extend tools/Makefile or tools/modular-build to do the glibc build
 * Extend the Scons build to be able to run the tests using glibc

Tidy ups:
 * Change glibc build system not to use wildcard rules (those generated into sysd-rules by Makerules)
    * This will make it easier to override files in sysdeps/i386 (for example) without having to remove sysdeps/i386 from the search path entirely.
    * This will also speed up the build, because GNU make's wildcard rules take quadratic time, and glibc uses a lot of them.
 * Remove copy of NaCl header files; pull these in from outside at build time
 * Remove dependency on Linux kernel headers
 * Unfork linker scripts: integrate linker script customisations into nacl-binutils, which has a shell script that generates linker scripts.
    * This might not be feasible because dynamically-linked executables require a different layout and different ELF headers from statically-linked executables.
 * Ensure that any unnecessary alignments are removed from the linker scripts in order to keep executable and library sizes down.  A "hello world" executable should be about 7k.
 * Test that large static TLS areas work.  Determine what size we should really pass to tls_init().
 * Ensure that we are building with an appropriate set of compiler error/warning flags.

Ideally:
 * Resolve the issue of ld.so being ET_EXEC vs. ET_DYN, so that we don't need two copies of it.
 * Resolve the issue of the executable's load address (see InitialDynamicLoad), so that we don't constrain address space unnecessarily.
 * Ensure that the dynamic linker supports TEXTRELs, i.e. libraries compiled without `-fPIC`.  This is specific to x86-32; ARM and x86-64 do not support TEXTRELs in general.
    * Normally the dynamic linker maps the code and then performs the relocations.  We would need to refactor this a little to perform the relocations before loading the code.

== Version control ==
nacl-glibc will be in Git in this repository: http://git.chromium.org/cgi-bin/gitweb.cgi?p=nacl-glibc.git

To check out the code, you can do:
{{{
git clone http://src.chromium.org/git/nacl-glibc.git
}}}

This is intended to replace the earlier nacl-glibc branch, which is at http://repo.or.cz/w/glibc/nacl-glibc.git