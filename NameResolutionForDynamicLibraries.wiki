#summary Discussion of how to map from library sonames to URLs to files

= Name resolution for dynamic libraries =

_Draft_

<wiki:toc/>

== Introduction ==

An important question for implementing dynamic library loading in Native Client is how libraries are named by executables and other libraries, and how the dynamic linker acquires libraries given these names.

The current plan for dynamic library support is to use ELF, the standard used in Linux and various other Unixes.  In ELF, a dynamic library is named by a short "soname", such as "libncurses.so.5".

On a Unix system, the responsibility for mapping a soname to a specific library file is effectively split between two components:

 * The OS provides a filesystem namespace (typically shared between all processes) which is populated with libraries when the application and its dependencies are _installed_.  This installation is often done by a _package manager_.
 * The dynamic linker treats the soname as a filename.  To find "libfoo.so.123", it tries to open "libfoo.so.123" in each directory in the _library search path_.

In the web browser, we do not have the same concept of installation:  There is no local filesystem namespace that is shared between all programs.  We would typically want to acquire library files by fetching them from URLs.  In this case the question becomes how to map sonames to URLs, and from URLs to files.

In this document we discuss two broad ways of managing this mapping:

 # *Map sonames to URLs outside the dynamic linker*:  When the dynamic linker needs to open a library, it invokes an out-of-process service, passing the short library name or a filename and receiving a file descriptor in response.
 # *Map sonames to URLs inside the dynamic linker*:  When the dynamic linker needs to open a library, it requests a URL to be fetched by the NaCl browser plugin and receives a file descriptor in response.

Furthermore, we discuss the possibility of changing ELF conventions and not using sonames.

First, we discuss potential goals against which these designs may be evaluated.

== Potential goals ==

Usability:
 * *Convenience*:  It should be easy to create a web app that uses dynamic libraries.  The Javascript/HTML/metadata for setting this up should be concise.
 * Support running *legacy applications* with minimal modifications.
    * We should not need to make intrusive changes to the build systems of existing libraries in order to use them with Native Client.
    * The dynamic linker itself is a legacy program.  Our solution for C dynamic libraries should readily extend to the library loaders for other languages.
 * *Testability*:  Ensure that NaCl-based web apps are easy to test.  It should be easy to run an isolated instance of a web app on a test server without depending on production instances.  Fixing URLs in binary files would make this harder.
 * *Avoid "DLL hell"*:
    * Allow a web app author to specify a fixed set of versions of libraries that are known to work together.
    * Allow a web app author to delegate the responsibility of picking library versions to another site (for example, to receive security updates).

Security considerations:
 * *Minimise trusted code*:  Implementing logic in trusted code unnecessarily increases the chance of vulnerabilities and makes the system less flexible.
 * *Integrity*:  Ensure that the library received is the one intended, even over an insecure network.  i.e. Allow use of "strong names".  For example, HTTP URL on its own is not a strong name, but an HTTP URL + secure hash is a strong name, provided the hash of the downloaded file is checked.
 * Support *secure compartmentalisation* of NaCl web apps:  It should be possible to create NaCl processes without the ability to access the DOM, fetch arbitrary URLs, etc.  Web apps may want to run NaCl programs without trusting them with DOM access and network access.  However, such programs may still need dynamic libraries.
 * *3-party library broker*:  Suppose site A wishes to use an up-to-date version of a library as specified by site B.  Site B should not need to host the library itself; it should be able to link to site C.  This should be possible without making site A vulnerable to site B.

Remote loading:
 * Support *pipelined fetching* of libraries in order to minimise latency:  When an executable depends on multiple libraries, it should be possible to queue the fetch requests for all libraries in one go, so that the download pipe is not empty for a round trip between requests.
 * Support *cross-origin fetching* of libraries, including UMP as well as CORS:  It should be possible for a web app on foo.com to use libraries hosted on bar.org.
 * Support *decentralised sharing* of libraries:  If foo.com and bar.org host identical copies of a library, using web apps on these sites should not cause the library to be downloaded twice.  (This is a longer-term goal.)

Maintenance issues:
 * *PNaCl* support:  We do not want to make assumptions that make it difficult to support PNaCl later on.
 * Use a *common libc build*:  Allow the same dynamic linker, libc and other libraries to work in both the browser and non-browser cases.  If we have to build different versions for inside and outside the browser, it will be a maintenance burden.
 * *Upstreamability* of libc:  We do not want to keep difficult-to-update glibc changes in our branch in the long term.

== Resolving sonames outside the dynamic linker ==

_TODO_

== Resolving sonames inside the dynamic linker ==

Suppose the dynamic linker is given the ability to fetch URLs and is expected to use this to load the libraries that an executable depends on.  This would place a number of constraints on the system.

=== Implementation constraints ===

The dynamic linker would need to talk to the NaCl browser plugin to request URLs.  To do this, it would need to speak the PPAPI-over-SRPC-over-IMC protocol that the NaCl browser plugin implements.  However, this protocol is currently not stable.

Assuming this protocol remains unstable, the dynamic linker would probably need to be linked to the NaCl PPAPI proxy library (libppruntime).  However, we cannot use the dynamically-linked version of libppruntime, since this would obviously create a Catch-22 situation:  In order to fetch a URL we need libppruntime loaded, but we need libppruntime loaded before we can fetch URLs.  So we would need to statically link libppruntime and its dependencies, which currently include libsrpc.  This would create some problems:

 * When the dynamic linker runs, during startup, libc is not yet loaded.  Many libc functions are not available.  Simple versions of malloc() and free() are available, but the dynamic linker's version of free() only frees memory for some allocation patterns.  libppruntime and libsrpc would need to be made to work in this context, which might be non-trivial.  libppruntime is currently written in C++, which is not available at the point we build nacl-glibc.  The NaCl toolchain build builds a C++ compiler only after building nacl-glibc, because libstdc++ depends on libc.  libppruntime also uses libpthread in some cases.

 * If libppruntime and libsrpc are changed so that the dynamic linker can be statically linked against them, any future change to these libraries will require testing to ensure that this still works.  So any change to libppruntime would require nacl-glibc to be rebuilt.  Otherwise libppruntime could have gained extra dependencies that do not work inside the dynamic linker.  nacl-glibc takes a relatively long time to build, so this would slow development.  So far, libppruntime developers have not needed to make changes that require nacl-glibc to be rebuilt.

 * We would potentially have two instances of libppruntime in the same process, which would cause problems.  This assumes that we would still have a dynamically-loaded libppruntime for NaCl applications to use.  The NaCl browser plugin expects to have one PPAPI-over-SRPC connection to the NaCl subprocess.  The two libppruntime instances would either have to share this connection, or the NaCl browser plugin would have to be changed to handle multiple connections.

A solution to these problems would be to stabilise the interface presented by the PPAPI-over-IMC protocol, or at least stabilise a subset of the protocol for loading URLs.  A minimal version of libppruntime could be written that is suitable for statically linking into the dynamic linker.

== Replacing sonames with URLs ==

_TODO_