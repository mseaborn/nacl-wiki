#summary Discussion of how to map from library sonames to URLs to files

= Name resolution for dynamic libraries =

_Draft_

<wiki:toc/>

== Introduction ==

An important question for implementing dynamic library loading in Native Client is how libraries are named by executables and other libraries, and how the dynamic linker acquires libraries given these names.

The current plan for dynamic library support is to use ELF, the standard used in Linux and various other Unixes.  In ELF, a dynamic library is named by a short "soname", such as "libncurses.so.5".

On a Unix system, the responsibility for mapping a soname to a specific library file is effectively split between two components:

 * The OS provides a filesystem namespace (typically shared between all processes) which is populated with libraries when the application and its dependencies are _installed_.  This installation is often done by a _package manager_.
 * The dynamic linker treats the soname as a filename.  To find "libfoo.so.123", it tries to open "libfoo.so.123" in each directory in the _library search path_.

In the web browser, we do not have the same concept of installation:  There is no local filesystem namespace that is shared between all programs.  We would typically want to acquire library files by fetching them from URLs.  In this case the question becomes how to map sonames to URLs, and from URLs to files.

In this document we discuss two broad ways of managing this mapping:

 # *Map sonames to URLs outside the dynamic linker*:  When the dynamic linker needs to open a library, it invokes an out-of-process service, passing the short library name or a filename and receiving a file descriptor in response.
 # *Map sonames to URLs inside the dynamic linker*:  When the dynamic linker needs to open a library, it requests a URL to be fetched by the NaCl browser plugin and receives a file descriptor in response.

Furthermore, we discuss the possibility of changing ELF conventions and not using sonames.

First, we discuss potential goals against which these designs may be evaluated.

== Potential goals ==

 * *Convenience*:  It should be easy to create a web app that uses dynamic libraries.  The Javascript/HTML/metadata for setting this up should be concise.
 * *Minimise trusted code*:  Implementing logic in trusted code unnecessarily increases the chance of vulnerabilities and makes the system less flexible.
 * Support *pipelined fetching* of libraries in order to minimise latency:  When an executable depends on multiple libraries, it should be possible to queue the fetch requests for all libraries in one go, so that the download pipe is not empty for a round trip between requests.
 * Support *cross-origin fetching* of libraries, including UMP as well as CORS:  It should be possible for a web app on foo.com to use libraries hosted on bar.org.
 * Support *decentralised sharing* of libraries:  If foo.com and bar.org host identical copies of a library, using web apps on these sites should not cause the library to be downloaded twice.  (This is a longer-term goal.)
 * Support *secure compartmentalisation* of NaCl web apps:  It should be possible to create NaCl processes without the ability to access the DOM, fetch arbitrary URLs, etc.  Web apps may want to run NaCl programs without trusting them with DOM access and network access.  However, such programs may still need dynamic libraries.
 * Support running *legacy applications* with minimal modifications.
    * We should not need to make intrusive changes to the build systems of existing libraries in order to use them with Native Client.
    * The dynamic linker itself is a legacy program.  Our solution for C dynamic libraries should readily extend to the library loaders for other languages.
 * Use a *common libc build*:  Allow the same dynamic linker, libc and other libraries to work in both the browser and non-browser cases.  If we have to build different versions for inside and outside the browser, it will be a maintenance burden.
 * *Testability*:  Ensure that NaCl-based web apps are easy to test.  It should be easy to run an isolated instance of a web app on a test server without depending on production instances.  Fixing URLs in binary files would make this harder.
 * *Integrity*:  Ensure that the library received is the one intended, even over an insecure network.  i.e. Allow use of "strong names".  For example, HTTP URL on its own is not a strong name, but an HTTP URL + secure hash is a strong name, provided the hash of the downloaded file is checked.
 * *Upstreamability* of libc:  We do not want to keep difficult-to-update glibc changes in our branch in the long term.
 * *PNaCl* support:  We do not want to make assumptions that make it difficult to support PNaCl later on.
 * *Avoid "DLL hell"*:
    * Allow a web app author to fix versions of libraries to a combination that is known to work together.
    * Allow a web app author to delegate the responsibility of picking library versions to another site (for example, to receive security updates).
 * *3-party library broker*:  Suppose site A wishes to use an up-to-date version of a library as specified by site B.  Site B should not need to host the library itself; it should be able to link to site C.  This should be possible without making site A vulnerable to site B.

== Mapping to URLs outside the dynamic linker ==

_TODO_

== Mapping to URLs inside the dynamic linker ==

_TODO_

== Replacing sonames with URLs ==

_TODO_